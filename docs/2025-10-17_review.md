  0. Orientation & Goals

  frz is a TUI-centric fuzzy finder with a clean separation of concerns across
  crates:
   - `crates/plugin-api/` exposes the stable surface for plugins (descriptors, registry,
     streaming helpers, dataset definitions).
   - `crates/tui/` provides reusable TUI components (tabs, tables, themes, input).
   - `src/` hosts the end-user application crate that wires settings, systems, UI runtime,
     and built-in plugins together.

  High-level goals I'd optimize for next:
   - Keep plugin-api narrow and stable; let most iteration happen in the app and TUI crates.
   - Preserve a clear line between "systems" (infra like search + fs index) and "plugins"
     (user-visible tabs composed from datasets and streaming logic).
   - Maintain rendering responsiveness even under heavy indexing by bounding per-tick work.

  1. Overall Architecture & Modularity

  The workspace separation is solid. The `src/` crate still carries a lot of wiring and
  orchestration, but the boundaries are already clear and healthy.

   - `src/` Crate Decomposition: Today `src/` handles CLI, settings, UI runtime, and
     orchestration. Extracting a `frz-core` crate could help if more systems appear, but it
     is not immediately necessary. A measured approach is preferable to avoid churn.
       - Opinion: Keep `frz-plugin-api` and `frz-tui` as the only public libraries for now;
         grow a `frz-core` only when we outgrow the current layout (e.g., adding non-UI
         workflows or multiple binaries).
       - TODO:
           - [ ] Identify code that would be shared by multiple binaries (if/when they
             arrive). Only then consider a `frz-core` crate.
           - [ ] Keep `src/systems/` as the home for infra (search/fs) used by built-ins
             and custom registries.

   - System vs. Plugin Distinction: `src/systems` provides background capabilities, while
     `src/plugins/builtin` (re-exporting separate plugin crates) surfaces user-facing tabs.
     This distinction is already good; I would keep terminology as-is.
       - Opinion: Do not fold `systems` into `plugins`. Systems are lower-level, reusable
         building blocks; plugins are UX-level tabs built on those systems.
       - TODO:
           - [ ] Document this layered model (systems -> plugins -> UI) in README/Docs.
           - [ ] Keep builtin plugins in their own crates (good for API hygiene and tests).

  2. Plugin System Scalability

  The current API is cohesive: a `SearchPlugin` pairs a static descriptor (UI + dataset)
  with streaming and selection logic. The context is already narrow
  (`PluginQueryContext`/`PluginSelectionContext` keep dependencies in check).

   - Context Objects: The contexts are intentionally small, which is great for decoupling.
       - Opinion: Keep them focused. If new needs arise, add small, capability-specific
         context structs rather than growing one monolith.
       - TODO:
           - [ ] When adding new plugin capabilities, introduce separate lightweight
             contexts rather than expanding `PluginQueryContext`.

   - Dynamic Capabilities (future): If plugins should contribute more than a search tab
     (e.g., commands, detail panels, status items), introduce an enum-based capability
     registry that preserves the simplicity of search tabs.
       - Sketch:
         ```rust
         pub enum Capability {
             SearchTab {
                 descriptor: &'static SearchPluginDescriptor,
                 plugin: Arc<dyn SearchPlugin>,
             },
             Command(CommandDescriptor),
             StatusItem(StatusDescriptor),
         }

         pub trait PluginBundle: Send + Sync {
             fn capabilities(&self) -> Vec<Capability>;
         }
         ```
       - TODO:
           - [ ] Prototype a minimal `Capability` enum in `plugin-api` behind a feature flag.
           - [ ] Extend the app crate to register `PluginBundle`s and hydrate the UI from
             discovered capabilities.

   - Example: Minimal Search Plugin
     ```rust
     use frz_plugin_api::{
         PluginQueryContext, PluginSelectionContext, SearchPlugin, SearchSelection, SearchStream,
         descriptors::{SearchPluginDescriptor, SearchPluginUiDefinition, SearchPluginDataset,
                       TableContext, TableDescriptor},
     };

     static DATASET: MyDataset = MyDataset;
     static DESCRIPTOR: SearchPluginDescriptor = SearchPluginDescriptor {
         id: "my-tab",
         ui: SearchPluginUiDefinition {
             tab_label: "My Tab",
             mode_title: "My Mode",
             hint: "Type to search",
             table_title: "Results",
             count_label: "Items",
         },
         dataset: &DATASET,
     };

     struct MyDataset;
     impl SearchPluginDataset for MyDataset {
         fn key(&self) -> &'static str { "my-tab" }
         fn total_count(&self, data: &frz_plugin_api::SearchData) -> usize { data.files.len() }
         fn build_table<'a>(&self, ctx: TableContext<'a>) -> TableDescriptor<'a> {
             // Convert filtered indices into rows; return headers/widths
             TableDescriptor::new(vec!["Path".into()], vec![], vec![])
         }
     }

     pub struct MyPlugin;
     impl SearchPlugin for MyPlugin {
         fn descriptor(&self) -> &'static SearchPluginDescriptor { &DESCRIPTOR }
         fn stream(&self, q: &str, s: SearchStream<'_>, c: PluginQueryContext<'_>) -> bool {
             frz_plugin_api::stream_files(c.data(), q, s, c.latest_query_id())
         }
         fn selection(&self, c: PluginSelectionContext<'_>, i: usize) -> Option<SearchSelection> {
             c.data().files.get(i).cloned().map(SearchSelection::File)
         }
     }
     ```

  3. Configuration Management

  The `src/settings` layering is solid (raw -> resolved) and already has good coverage.

   - Validation & Rich Errors: Continue to surface precise diagnostics augmented with
     source provenance (file path/env/flag). Consider a small typed error enum with
     context.
       - Sketch:
         ```rust
         use thiserror::Error;

         #[derive(Debug, Error)]
         pub enum ConfigError {
             #[error("invalid value for {key} in {source}: {reason}")]
             Invalid { key: String, source: String, reason: String },
         }

         fn validate(resolved: &ResolvedConfig) -> Result<(), ConfigError> { Ok(()) }
         ```
       - TODO:
           - [ ] Add a post-resolve validation pass that accumulates user-facing errors.
           - [ ] Ensure errors carry the originating source (path/env/flag) when available.

  4. State Management and UI

  The UI runtime is thoughtfully bounded: per-tick index processing time and batch sizes
  cap work to keep frames smooth. The background worker pattern is clean and testable.

   - View vs. Model State: `App` already separates transient view buffers
     (`tab_states`, `table_state`) from `SearchData` (the model). Keep it that way.
       - TODO:
           - [ ] Add a short comment block in `src/ui/state.rs` describing the two layers.
           - [ ] Keep only frame-necessary state in the UI struct; push everything else to
             the worker or data layer.

   - Event Loop Hygiene: The event thread forwards `crossterm` events via an mpsc channel.
     Consider coalescing repeated resize events and throttling key repeats.
       - Sketch (conceptual):
         ```rust
         // Pseudo: drop stale resize events before drawing
         while let Ok(Event::Resize(..)) = event_rx.try_recv() { /* drain */ }
         ```
       - TODO:
           - [ ] Drain/coalesce resize bursts to avoid redundant redraws.
           - [ ] Consider `crossbeam-channel` for better `select!` ergonomics if needed.

   - Highlighting & Theming: `frz_tui` already exposes highlight helpers. Document a simple
     recipe for enabling/disabling highlights per tab to keep UX consistent.

  5. Error Handling

  For the library-facing crates (`plugin-api`, `tui`), prefer typed errors. The binary can
  keep using `anyhow` at the edges.

   - Example with `thiserror`:
     ```rust
     use thiserror::Error;

     #[derive(Debug, Error)]
     pub enum FsIndexError {
         #[error("walk failed: {0}")] Walk(#[from] ignore::Error),
         #[error("io: {0}")] Io(#[from] std::io::Error),
     }
     ```
   - TODO:
       - [ ] Introduce crate-specific error enums in library crates as surfaces stabilize.
       - [ ] Audit `unwrap`/`expect` in non-test code and replace where sensible.

  6. Testing

  Great start with unit tests in TUI components and runtime. Add thin integration tests and
  a focused TUI snapshot test or two.

   - TUI Snapshot Test Sketch:
     ```rust
     use ratatui::{backend::TestBackend, Terminal};
     let backend = TestBackend::new(80, 20);
     let mut terminal = Terminal::new(backend)?;
     terminal.draw(|f| app.draw(f))?;
     // assert over the buffer or serialize for snapshot
     ```
   - Integration Test Idea:
     ```rust
     // spin a SearchPluginRegistry with a dummy plugin and exercise the worker loop
     let data = SearchData::default();
     let mut reg = SearchPluginRegistry::new();
     reg.register(MyPlugin);
     // spawn worker and assert it streams results for a query
     ```
   - TODO:
       - [ ] Add a minimal end-to-end test that runs the search worker with a mock plugin.
       - [ ] Add a TUI component snapshot or buffer assertion test.

  7. Performance & Scalability

   - Batching & Backpressure: Index updates are already time/batch bounded per tick
     (`MAX_INDEX_UPDATES_PER_TICK`, `MAX_INDEX_PROCESSING_TIME`). Consider exposing these
     as settings to accommodate different hardware.
       - TODO:
           - [ ] Make per-tick processing bounds configurable via settings.

   - Fuzzy Scoring Tunables: `frizbee` config is derived from query length and dataset size.
     Consider path-segment-aware tweaks (boost final segment, de-emphasize deep folders).
       - Sketch:
         ```rust
         // precompute per-file weights from path segments; add to score aggregator
         let weight = if path.ends_with(query_last_token) { 10 } else { 0 };
         aggregator.push(index, base_score + weight);
         ```

   - Memory: For very large repos, consider slicing `SearchData` into arenas or keeping
     heavy fields in side arrays to keep cache locality on hot paths (indices + scores).

  8. Indexing Enhancements

   - File Watching (optional mode): After initial index, watch for changes to keep data
     fresh using `notify` (debounced) and feed small `IndexUpdate`s.
       - Sketch:
         ```rust
         use notify::{Watcher, RecommendedWatcher, RecursiveMode, Event};
         let mut watcher = RecommendedWatcher::new(move |res: Result<Event, _>| {
             // translate events into IndexUpdate batches
         }, Default::default())?;
         watcher.watch(root, RecursiveMode::Recursive)?;
         ```
       - TODO:
           - [ ] Add a `filesystem.watch` setting gated behind a feature flag.

   - Cache Strategy: You already stream cached preview/full entries, which is excellent.
     Consider persisting facet totals alongside files so the UI can render counts earlier.

  9. UX & Accessibility

   - Keymap: Expose a configurable keymap with command names (next/prev/select/toggle-tab).
     Keep defaults sane and document them.
   - Color Contrast: Provide a high-contrast theme variant; ensure progress throbber remains
     visible on dim terminals.
   - Hints: The per-mode `hint` string is great—add a one-liner in the README showing where
     to override it per tab.

  10. Observability

   - Introduce `tracing` spans in the worker (query start/abort/finish), indexer batches,
     and UI ticks to aid performance tuning.
     ```rust
     use tracing::{info_span, instrument};
     #[instrument(skip(stream, context))]
     fn stream(..) { /* ... */ }
     ```
   - Provide an env var like `FRZ_LOG=debug` to enable a default subscriber in the binary.

  11. Cross-Platform Concerns

   - Path Normalization: You already normalize path separators; continue to ensure Windows
     drive-letter and UNC paths are handled when building display strings.
   - Terminal Quirks: Consider guarding against terminals that misreport sizes; clamp
     widths/heights defensively when laying out.

  12. Documentation & Examples

   - Add a minimal “write a plugin” walkthrough in README using the snippet above.
   - Clarify the systems/plugins/UI layering with a diagram.
   - Show how to swap out builtin plugins using `SearchPluginRegistry::deregister_by_id`.

  13. Open Questions

   - Should plugins be able to contribute detail panels or actions attached to selection?
   - Would dynamic loading (e.g., `libloading`) be in scope, or is compile-time composition
     preferred for simplicity and safety?
