# 2025-08-17 TODO — Opinionated Roadmap

Objective: bring the project in line with the 2025‑08‑17 review by delivering small, verifiable steps. Each section lists concrete, ordered tasks with acceptance criteria. Sub‑tasks and snippets help clarify intent. No code changes are made by this document itself.

## Phase 0 — Docs & Orientation

- [x] Document the layered model (systems → plugins → UI)
  - [x] Add `docs/ARCHITECTURE.md` describing roles of `crates/plugin-api`, `crates/tui`, and `src/` (app wiring)
  - [x] Link `docs/ARCHITECTURE.md` from `README.md` and briefly explain how built-in plugins are registered
  - Acceptance: New doc exists, README has a short “Architecture” section with link

- [x] Clarify “systems” vs “plugins” in docs
  - [x] Add a short section in `docs/ARCHITECTURE.md#Layers` that defines systems (infra: search worker, filesystem indexer) and plugins (UX tabs built on systems)
  - Acceptance: Terms are consistently defined and used across docs

## Phase 1 — Plugin API: Capability scaffolding (feature‑gated)

Intent: Keep current `SearchPlugin` as‑is; prototype future breadth using a non‑breaking feature flag.

- [x] Introduce feature flag `capabilities` in `crates/plugin-api/Cargo.toml`
  - [x] Add optional `Capability` enum and `PluginBundle` trait under `#[cfg(feature = "capabilities")]`
  - [x] Ensure `lib.rs` re‑exports are gated and don’t affect current API
  - Acceptance: `cargo check` passes with and without the feature

- [x] Prototype bundle registration (internal only)
  - [x] Add `PluginBundle` sampling to registry behind the same feature flag (no callers yet)
  - [x] Keep `SearchPluginRegistry` behavior stable if the feature is off
  - Acceptance: No behavior changes without the feature enabled

- [x] Add a minimal example bundle
  - [x] Create `examples/capability_demo.rs` (feature‑gated) that returns a single `Capability::SearchTab`
  - Acceptance: Example builds and runs behind `--features capabilities`

Snippet (shape only):
```rust
// crates/plugin-api/src/capabilities.rs
#[cfg(feature = "capabilities")]
pub enum Capability {
    SearchTab { descriptor: &'static SearchPluginDescriptor, plugin: std::sync::Arc<dyn SearchPlugin> },
    // Command(CommandDescriptor),
    // StatusItem(StatusDescriptor),
}

#[cfg(feature = "capabilities")]
pub trait PluginBundle: Send + Sync {
    fn capabilities(&self) -> Vec<Capability>;
}
```

## Phase 2 — Configuration: Validation + rich errors

- [x] Add `thiserror` to the app crate (binary) and define `ConfigError`
  - [x] Add a validation pass after resolution in `src/settings/resolved.rs`
  - [x] Include key, value (where sensible), and source (file/env/flag) in diagnostics
  - Acceptance: Invalid configs produce actionable messages; `--print-config` still works

Snippet:
```rust
// src/settings/resolved.rs (conceptual)
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("invalid value for {key} in {source}: {reason}")]
    Invalid { key: String, source: String, reason: String },
}

pub fn validate(cfg: &ResolvedConfig) -> Result<(), ConfigError> {
    // e.g., ensure max results > 0
    Ok(())
}
```

## Phase 3 — UI Runtime hygiene

- [x] Coalesce bursty resize events before draw
  - [x] Drain `Resize` events from `event_rx` just before `terminal.draw` in `src/ui/runtime.rs`
  - Acceptance: No flicker; stable frame rate under repeated terminal resizes

- [x] Guard against overdraw with bounded per‑tick work (keep current bounds)
  - [x] Document rationale at top of `src/ui/indexing.rs` (MAX_UPDATES / MAX_TIME)
  - Acceptance: Comment present; behavior unchanged

Snippet (conceptual):
```rust
// before draw, drop stale resizes
while let Ok(ratatui::crossterm::event::Event::Resize(..)) = event_rx.try_recv() {}
```

## Phase 4 — Typed errors in library crates (incremental)

- [x] Introduce typed errors where external callers benefit most
  - [x] Add error enums in `crates/plugin-api` for public fallible APIs (if any)
  - [x] Keep `anyhow` in the binary for ergonomic top‑level handling
  - Acceptance: Public library APIs no longer require `anyhow` to differentiate failures

Snippet:
```rust
// crates/plugin-api/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum PluginApiError {
    #[error("registry conflict for id {0}")] RegistryConflict(&'static str),
}
```

## Phase 5 — Tests: unit, integration, and TUI snapshots

- [x] Worker integration test with a dummy plugin
  - [x] In `crates/plugin-api` or app crate tests, register a tiny `SearchPlugin` and assert a streamed result
  - Acceptance: Test proves `spawn`/stream/selection plumbing

- [x] TUI buffer assertion test for a small component
  - [x] Use `ratatui::backend::TestBackend` to render a tiny view and assert buffer content
  - Acceptance: One green test that exercises a render path deterministically

Snippet:
```rust
use ratatui::{backend::TestBackend, Terminal};
let backend = TestBackend::new(80, 4);
let mut term = Terminal::new(backend)?;
term.draw(|f| app.draw(f))?;
// assert on cells in term.backend().buffer()
```

## Phase 6 — Performance tunables (configurable)

- [ ] Make per‑tick bounds configurable via settings
  - [ ] Expose values mirroring `MAX_INDEX_UPDATES_PER_TICK` and `MAX_INDEX_PROCESSING_TIME` in `src/settings/raw/ui.rs`
  - [ ] Thread them into `App` construction and use in `src/ui/indexing.rs`
  - Acceptance: Defaults match current constants; config can increase/decrease limits

- [ ] Explore scoring tweaks (path‑segment boosts) behind a flag
  - [ ] Prototype optional additive weight for final path segment matches
  - Acceptance: Off by default; measurable impact when on in large trees

## Phase 7 — Indexing enhancements (optional watch)

- [ ] Add optional `filesystem.watch` setting (feature‑gated)
  - [ ] Use `notify` to watch root; debounce and batch into small `IndexUpdate`s
  - [ ] Ensure UI stays stable (don’t refresh until user edits, unless query dirty)
  - Acceptance: With watch enabled, small edits reflect in results after user input

Snippet (shape only):
```rust
use notify::{RecommendedWatcher, RecursiveMode, Watcher};
let mut watcher = RecommendedWatcher::new(move |res| { /* batch to IndexUpdate */ }, Default::default())?;
watcher.watch(&root, RecursiveMode::Recursive)?;
```

## Phase 8 — UX & Accessibility

- [ ] Add a high‑contrast theme in `crates/tui/src/theme/`
  - [ ] Ensure throbber and muted text remain visible on dim backgrounds
  - Acceptance: Theme appears in `--list-themes` and renders legibly

- [ ] Keymap documentation and hooks
  - [ ] Document current keybindings from `src/ui/actions.rs`
  - [ ] Define config shape for overrides (future), no behavior change yet
  - Acceptance: Docs show how overrides would look; config reserved keys don’t conflict

## Phase 9 — Observability

- [ ] Add `tracing` spans for worker and indexer hot paths
  - [ ] Query lifecycle: start/abort/finish; indexing batches; UI tick
  - [ ] Optional env toggle `FRZ_LOG=debug` to enable a default subscriber in the binary
  - Acceptance: With env var set, logs show spans; default remains quiet

Snippet:
```rust
use tracing::{instrument};
#[instrument(skip(stream, context))]
fn stream(..) { /* ... */ }
```

## Phase 10 — Cross‑platform sanity

- [ ] Path normalization tests
  - [ ] Add tests covering `tags_for_relative_path` and path separator handling
  - Acceptance: Tests pass on Windows and Unix; no regressions in display strings

## Phase 11 — Examples & Plugin tutorial

- [ ] Write a “Build a search tab plugin” guide
  - [ ] Add `docs/PLUGIN_TUTORIAL.md` using a stripped version of the minimal plugin snippet
  - [ ] Cross‑link from `README.md`
  - Acceptance: Tutorial compiles as an example or is trivially adaptable

---

## Execution order (suggested sprints)

1) Phase 0, 3, 5 — docs + runtime hygiene + one snapshot test
2) Phase 2, 6 — config validation + performance settings
3) Phase 1 — capability scaffolding behind a feature flag + example
4) Phase 9 — tracing, then Phase 8 — high‑contrast theme
5) Phase 7 — optional file watch, Phase 10 — cross‑platform tests, Phase 11 — tutorial

## Non‑goals (for now)

- Extracting a `frz-core` crate: defer until multiple binaries or non‑UI workflows appear
- Dynamic loading for plugins: keep compile‑time composition for simplicity and safety

